<!DOCTYPE html>
<html lang="pt-br">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Bullet Mage ‚Äî RotMG-like ‚Ä¢ Anoma Intents</title>
  <style>
    html, body { height: 100%; margin: 0; background: #0b0f13; color: #e8eef5; font-family: system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Cantarell, Noto Sans, Arial, "Apple Color Emoji", "Segoe UI Emoji"; }
    .wrap { display: grid; grid-template-rows: auto 1fr auto; height: 100%; }
    header { padding: 10px 14px; background: #0f151c; border-bottom: 1px solid #1e293b; display: flex; gap: 12px; align-items: center; }
    header h1 { font-size: 16px; margin: 0; letter-spacing: .3px; }
    header .btn { background: #111827; border: 1px solid #334155; color: #e5e7eb; padding: 6px 10px; border-radius: 10px; cursor: pointer; }
    header .btn:hover { filter: brightness(1.15); }
    #gameHolder { position: relative; display: grid; place-items: center; background: radial-gradient(1000px 600px at 20% 30%, #0f1620, #0b0f13 70%); }
    canvas { image-rendering: pixelated; background: #0a0e12; border: 1px solid #1f2937; border-radius: 10px; max-width: 100%; max-height: 100%; }
    #hud { position: absolute; inset: 0; pointer-events: none; }
    .bar { position: absolute; left: 16px; top: 14px; width: 240px; height: 10px; background: #1f2937; border-radius: 10px; border: 1px solid #374151; }
    .bar > span { display: block; height: 100%; background: linear-gradient(90deg, #ef4444, #f87171); border-radius: 10px; }
    .mana { top: 30px; }
    .mana > span { background: linear-gradient(90deg, #3b82f6, #60a5fa); }
    .text { position: absolute; right: 16px; top: 12px; text-align: right; font-size: 14px; opacity: .9; }
    footer { padding: 10px 14px; background: #0f151c; border-top: 1px solid #1e293b; font-size: 12px; display:flex; gap:10px; align-items:center; }
    kbd { background:#111827; border:1px solid #374151; padding:2px 6px; border-radius:6px; font-size: 11px; }
    .mobile { display:none; }
    @media (max-width: 760px) { .mobile{display:block;} }
    .toast { position:absolute; left:50%; transform:translateX(-50%); top:14px; background:#111827; border:1px solid #374151; padding:8px 12px; border-radius:10px; font-size:12px; opacity:.95; }
  </style>
</head>
<body>
<div class="wrap">
  <header>
  <h1 style="margin:0; font-size:16px; letter-spacing:.3px;">ANOMA INTENTS</h1>
  <span style="margin-left:auto; font-size:12px; opacity:.8;">By: 0xEljefe</span>
</header>


  <div id="gameHolder">
    <canvas id="game" width="768" height="432"></canvas>
    <div id="hud">
      <div class="bar hp"><span id="hpFill" style="width:100%"></span></div>
      <div class="bar mana"><span id="mpFill" style="width:100%"></span></div>
      <div class="text" id="status">Wave 0 ‚Ä¢ 0 pts</div>
      <div class="toast mobile">Controles: Joystick virtual + Toque para atirar</div>
    </div>
  </div>

  <footer>
    Controles: <kbd>WASD</kbd> mover, mouse para mirar, clique/segurar para atirar, <kbd>Espa√ßo</kbd> dash, <kbd>P</kbd> pausar. Coleta <strong>Intents</strong> (‚ö°/üõ°Ô∏è/üí•) ‚Äî combine 2 iguais para buffs. Dica: mantenha dist√¢ncia!
  </footer>
</div>

<script>
(() => {
  const canvas = document.getElementById('game');
  const ctx = canvas.getContext('2d');
  const statusEl = document.getElementById('status');
  const hpFill = document.getElementById('hpFill');
  const mpFill = document.getElementById('mpFill');
  const btnStart = document.getElementById('btnStart');
  const btnPause = document.getElementById('btnPause');

  // --- Helpers
  const rand = (a, b) => a + Math.random() * (b - a);
  const clamp = (v, a, b) => Math.max(a, Math.min(b, v));
  const dist2 = (a, b) => { const dx=a.x-b.x, dy=a.y-b.y; return dx*dx+dy*dy; };
  const now = () => performance.now();

  // --- Input
  const keys = {}; window.addEventListener('keydown', e=> keys[e.key.toLowerCase()]=true);
  window.addEventListener('keyup', e=> keys[e.key.toLowerCase()]=false);

  // Mouse
  const mouse = { x: canvas.width/2, y: canvas.height/2, down:false };
  canvas.addEventListener('mousemove', e=>{
    const rect = canvas.getBoundingClientRect();
    mouse.x = (e.clientX-rect.left) * (canvas.width/rect.width);
    mouse.y = (e.clientY-rect.top) * (canvas.height/rect.height);
  });
  canvas.addEventListener('mousedown', ()=> mouse.down=true);
  canvas.addEventListener('mouseup', ()=> mouse.down=false);
  canvas.addEventListener('mouseleave', ()=> mouse.down=false);

  // Mobile touch: simple joystick + shoot on second finger / tap
  let joy = { active:false, id:null, ox:0, oy:0, dx:0, dy:0 };
  canvas.addEventListener('touchstart', e=>{
    e.preventDefault();
    for (const t of e.changedTouches) {
      if (!joy.active) { joy.active=true; joy.id=t.identifier; joy.ox=t.clientX; joy.oy=t.clientY; joy.dx=0; joy.dy=0; }
      else { mouse.down=true; }
    }
  }, {passive:false});
  canvas.addEventListener('touchmove', e=>{
    for (const t of e.changedTouches) if (t.identifier===joy.id) { joy.dx = t.clientX-joy.ox; joy.dy = t.clientY-joy.oy; }
  });
  canvas.addEventListener('touchend', e=>{
    for (const t of e.changedTouches) {
      if (t.identifier===joy.id) { joy.active=false; joy.id=null; joy.dx=joy.dy=0; }
      else { mouse.down=false; }
    }
  });

  // --- Game State
  const G = {
    running: false,
    paused: false,
    last: 0,
    time: 0,
    score: 0,
    wave: 0,
    entities: [],
    bullets: [],
    enemyBullets: [],
    pickups: [],
    effects: [],
    player: null,
  };

  // --- Entities
  function makePlayer() {
    return {
      type: 'player',
      x: canvas.width/2, y: canvas.height/2,
      vx:0, vy:0,
      speed: 160,
      hp: 100, hpMax: 100,
      mp: 100, mpMax: 100,
      fireCooldown: 0,
      fireRate: 120, // ms
      projSpeed: 360,
      dashCd: 0,
      dashTime: 0,
      dashSpeed: 400,
      intents: {}, // collected buffs
    };
  }

  function makeEnemy(kind) {
    const k = kind || ['chaser','turret','spinner'][Math.floor(Math.random()*3)];
    let x,y; // spawn at edges
    if (Math.random()<.5) { x = Math.random()<.5 ? -20 : canvas.width+20; y = rand(0, canvas.height); }
    else { x = rand(0, canvas.width); y = Math.random()<.5 ? -20 : canvas.height+20; }
    const base = { type: 'enemy', k, x, y, vx:0, vy:0, hp: 14 + G.wave*2, r: 10, fire: 0 };
    return base;
  }

  function makeBullet(x,y,dx,dy,speed, from) {
    const len = Math.hypot(dx,dy)||1; dx/=len; dy/=len;
    return { type:'bullet', x, y, vx:dx*speed, vy:dy*speed, r:3, from };
  }

  function makePickup(x,y) {
    const kinds = ['power','shield','burst']; // ‚ö°, üõ°Ô∏è, üí•
    const k = kinds[Math.floor(Math.random()*kinds.length)];
    return { type:'pickup', k, x, y, r:8, ttl: 10000 };
  }

  function pushEffect(x,y,txt) { G.effects.push({x,y,txt,ttl:800}); }

  // --- Logic
  function reset() {
    G.running = true; G.paused = false; G.time = 0; G.last = now();
    G.score = 0; G.wave = 0; G.entities.length=0; G.bullets.length=0; G.enemyBullets.length=0; G.pickups.length=0; G.effects.length=0;
    G.player = makePlayer();
  }

  function spawnWave() {
    G.wave++;
    const n = 3 + Math.min(20, Math.floor(G.wave*1.3));
    for (let i=0;i<n;i++) G.entities.push(makeEnemy());
    pushEffect(canvas.width/2, 40, `Wave ${G.wave}`);
  }

  function playerControls(p, dt) {
    let ax=0, ay=0;
    if (keys['w']||keys['arrowup']) ay -= 1;
    if (keys['s']||keys['arrowdown']) ay += 1;
    if (keys['a']||keys['arrowleft']) ax -= 1;
    if (keys['d']||keys['arrowright']) ax += 1;

    // Mobile joystick influence
    if (joy.active) {
      ax += clamp(joy.dx/40, -1, 1);
      ay += clamp(joy.dy/40, -1, 1);
    }

    const len = Math.hypot(ax,ay); if (len>0){ ax/=len; ay/=len; }
    const spd = (p.dashTime>0? p.dashSpeed : p.speed);
    p.vx = ax*spd; p.vy = ay*spd;

    p.x = clamp(p.x + p.vx*dt, 10, canvas.width-10);
    p.y = clamp(p.y + p.vy*dt, 10, canvas.height-10);

    // Dash
    if ((keys[' '] || keys['space']) && p.dashCd<=0 && p.mp>=20) { p.dashTime=0.18; p.dashCd=1.0; p.mp-=20; pushEffect(p.x,p.y,'Dash!'); }
    if (p.dashTime>0) p.dashTime -= dt; else p.dashTime=0;
    if (p.dashCd>0) p.dashCd -= dt;

    // Fire
    p.fireCooldown -= dt*1000;
    const aim = {x: mouse.x, y: mouse.y};
    const auto = mouse.down;
    const canShoot = p.fireCooldown<=0 && p.mp>=1;
    if (auto && canShoot) {
      const dx = aim.x - p.x, dy = aim.y - p.y;
      G.bullets.push(makeBullet(p.x, p.y, dx, dy, p.projSpeed, 'player'));
      p.fireCooldown = p.fireRate * (p.intents.power? 0.75:1);
      p.mp -= 1*(p.intents.power? 0.6:1);
    }

    // regen
    p.mp = clamp(p.mp + 8*dt, 0, p.mpMax);
  }

  function enemyAI(e, dt) {
    const p = G.player; if (!p) return;
    if (e.k==='chaser') {
      const dx=p.x-e.x, dy=p.y-e.y; const l=Math.hypot(dx,dy)||1;
      e.vx = dx/l * (40+G.wave*4); e.vy = dy/l * (40+G.wave*4);
      e.x += e.vx*dt; e.y += e.vy*dt;
      e.fire -= dt; if (e.fire<=0) { // shotgun
        e.fire = Math.max(0.9 - G.wave*0.02, 0.35);
        const ang = Math.atan2(dy,dx);
        for (let i=-1;i<=1;i++) {
          const a = ang + i*0.12; G.enemyBullets.push(makeBullet(e.x,e.y, Math.cos(a),Math.sin(a), 140+G.wave*6, 'enemy'));
        }
      }
    } else if (e.k==='turret') {
      e.fire -= dt; if (e.fire<=0) { e.fire = Math.max(1.2 - G.wave*0.03, 0.4);
        const dx=p.x-e.x, dy=p.y-e.y; const l=Math.hypot(dx,dy)||1;
        G.enemyBullets.push(makeBullet(e.x,e.y, dx/l, dy/l, 120+G.wave*5, 'enemy'));
      }
      // circle move
      e.x += Math.sin(G.time*0.8+e.y*0.02)*20*dt; e.y += Math.cos(G.time*0.7+e.x*0.02)*20*dt;
    } else if (e.k==='spinner') {
      // orbit player and spray
      const dx=p.x-e.x, dy=p.y-e.y; const l=Math.hypot(dx,dy)||1;
      const toward = 60+G.wave*3; e.x += dx/l*toward*dt; e.y += dy/l*toward*dt;
      e.fire -= dt; if (e.fire<=0){ e.fire = 0.12; const base = G.time*4; for (let i=0;i<6;i++){ const a=base+i*Math.PI/3; G.enemyBullets.push(makeBullet(e.x,e.y, Math.cos(a), Math.sin(a), 100+G.wave*7, 'enemy')); } }
    }
  }

  function handleCollisions(dt) {
    const p = G.player; if (!p) return;
    // player bullets vs enemies
    for (let i=G.bullets.length-1;i>=0;i--) {
      const b=G.bullets[i];
      for (let j=G.entities.length-1;j>=0;j--) {
        const e=G.entities[j]; if (e.type!=='enemy') continue;
        const r = (b.r + e.r); if (dist2(b,e) <= r*r) {
          G.entities[j].hp -= (p.intents.power? 10:7);
          G.bullets.splice(i,1); pushEffect(e.x,e.y,'-');
          if (G.entities[j].hp<=0) {
            // drop intent chance
            if (Math.random() < 0.25) G.pickups.push(makePickup(e.x,e.y));
            G.entities.splice(j,1); G.score += 10 + G.wave;
          }
          break;
        }
      }
    }

    // enemy bullets vs player
    for (let i=G.enemyBullets.length-1;i>=0;i--) {
      const b=G.enemyBullets[i];
      const r = b.r + 6;
      if (dist2(b,p) <= r*r) {
        if (p.intents.shield) { p.intents.shield = 0; pushEffect(p.x,p.y,'üõ°Ô∏è Block'); }
        else { p.hp -= 10; pushEffect(p.x,p.y,'ouch'); }
        G.enemyBullets.splice(i,1);
      }
    }

    // enemies touching player
    for (let i=G.entities.length-1;i>=0;i--) {
      const e=G.entities[i];
      const r = e.r + 6; if (dist2(e,p)<=r*r) {
        p.hp -= 10*dt; // damage over time
      }
    }

    // pickups
    for (let i=G.pickups.length-1;i>=0;i--) {
      const a = G.pickups[i]; a.ttl -= dt*1000; if (a.ttl<=0) { G.pickups.splice(i,1); continue; }
      const r=a.r+6; if (dist2(a,p)<=r*r) {
        // Anoma-like: combine 2 intents iguais para ativar buff
        a.collected = true;
        p.intents[a.k] = (p.intents[a.k]||0)+1;
        if (p.intents[a.k]>=2) {
          if (a.k==='power') { pushEffect(p.x,p.y,'‚ö° Power'); }
          if (a.k==='shield') { pushEffect(p.x,p.y,'üõ°Ô∏è Shield'); }
          if (a.k==='burst') { pushEffect(p.x,p.y,'üí• Burst'); // radial clear
            for (let j=G.entities.length-1;j>=0;j--) if (dist2(G.entities[j], p) < 160*160) { G.entities[j].hp -= 18; }
          }
          // keep it at 1 (active) after matching pair
          p.intents[a.k] = 1;
        }
        G.pickups.splice(i,1);
      }
    }
  }

  function update(dt) {
    if (!G.running || G.paused) return;
    G.time += dt;

    // Spawn waves
    if (G.entities.length===0) spawnWave();

    // Update bullets
    for (const arr of [G.bullets, G.enemyBullets]) {
      for (let i=arr.length-1;i>=0;i--) { const b=arr[i]; b.x+=b.vx*dt; b.y+=b.vy*dt; if (b.x<-20||b.x>canvas.width+20||b.y<-20||b.y>canvas.height+20) arr.splice(i,1); }
    }

    // Update enemies
    for (let i=G.entities.length-1;i>=0;i--) { const e=G.entities[i]; enemyAI(e, dt); }

    // Effects decay
    for (let i=G.effects.length-1;i>=0;i--) { const ef=G.effects[i]; ef.ttl -= dt*1000; if (ef.ttl<=0) G.effects.splice(i,1); }

    // Player
    playerControls(G.player, dt);

    // Collisions
    handleCollisions(dt);

    // Death
    if (G.player.hp<=0) { G.running=false; pushEffect(canvas.width/2, canvas.height/2, 'üíÄ Voc√™ caiu! Clique em Jogar.'); }

    // HUD
    statusEl.textContent = `Wave ${G.wave} ‚Ä¢ ${G.score} pts`;
    hpFill.style.width = `${100*G.player.hp/G.player.hpMax}%`;
    mpFill.style.width = `${100*G.player.mp/G.player.mpMax}%`;
  }

  // --- Render (pixel-art-ish shapes)
  function draw() {
    // bg grid
    ctx.fillStyle = '#091017'; ctx.fillRect(0,0,canvas.width,canvas.height);
    ctx.strokeStyle = '#0f1b2a'; ctx.lineWidth = 1;
    const grid = 24; ctx.beginPath();
    for (let x=0;x<canvas.width;x+=grid){ ctx.moveTo(x,0); ctx.lineTo(x,canvas.height);} 
    for (let y=0;y<canvas.height;y+=grid){ ctx.moveTo(0,y); ctx.lineTo(canvas.width,y);} 
    ctx.stroke();

    // player (mago vermelho com cajado)
    const p = G.player; if (p) {
      // body
      ctx.save();
      ctx.translate(p.x, p.y);
      // robes
      ctx.fillStyle = '#b91c1c';
      ctx.fillRect(-6, -8, 12, 16);
      // head
      ctx.fillStyle = '#fef3c7'; ctx.fillRect(-4,-14,8,6);
      // visor roxo/detalhe
      ctx.fillStyle = '#7c3aed'; ctx.fillRect(-3,-13,6,3);
      // staff (cajado)
      const ang = Math.atan2(mouse.y-p.y, mouse.x-p.x);
      ctx.rotate(ang);
      ctx.fillStyle = '#8b5cf6'; ctx.fillRect(6,-2, 10, 4);
      ctx.fillStyle = '#f59e0b'; ctx.fillRect(16,-3, 4, 6);
      ctx.restore();
    }

    // bullets
    for (const b of G.bullets) { ctx.fillStyle = '#eab308'; ctx.fillRect(b.x-2,b.y-2,4,4); }
    for (const b of G.enemyBullets) { ctx.fillStyle = '#60a5fa'; ctx.fillRect(b.x-2,b.y-2,4,4); }

    // enemies
    for (const e of G.entities) {
      if (e.k==='chaser') ctx.fillStyle = '#ef4444';
      else if (e.k==='turret') ctx.fillStyle = '#22c55e';
      else ctx.fillStyle = '#f97316';
      ctx.beginPath(); ctx.arc(e.x, e.y, e.r, 0, Math.PI*2); ctx.fill();
    }

    // pickups (Intents)
    for (const a of G.pickups) {
      ctx.save(); ctx.translate(a.x,a.y); ctx.fillStyle = '#111827'; ctx.fillRect(-8,-8,16,16); ctx.fillStyle = '#e5e7eb';
      ctx.font = '12px monospace'; ctx.textAlign='center'; ctx.textBaseline='middle';
      const glyph = a.k==='power'? '‚ö°' : a.k==='shield' ? 'üõ°Ô∏è' : 'üí•';
      ctx.fillText(glyph, 0, 1);
      ctx.restore();
    }

    // effects text
    for (const ef of G.effects) {
      ctx.save(); ctx.globalAlpha = Math.max(0, ef.ttl/800); ctx.fillStyle = '#e5e7eb';
      ctx.font = '12px monospace'; ctx.textAlign='center';
      ctx.fillText(ef.txt, ef.x, ef.y - (1-ef.ttl/800)*12);
      ctx.restore();
    }
  }

  // --- Game Loop
  function tick() {
    const t = now();
    const dt = Math.min(0.033, (t - G.last) / 1000);
    G.last = t;
    if (G.running && !G.paused) update(dt);
    draw();
    requestAnimationFrame(tick);
  }

  // --- UI
  btnStart.addEventListener('click', ()=> reset());
  btnPause.addEventListener('click', ()=> { G.paused=!G.paused; });
  window.addEventListener('keydown', e=>{ if (e.key.toLowerCase()==='p') G.paused=!G.paused; });

  // Fit canvas responsively (keep aspect)
  function fit() {
    const holder = document.getElementById('gameHolder');
    const w = holder.clientWidth, h = holder.clientHeight;
    const baseW = 768, baseH = 432; // 16:9
    const scale = Math.min(w/baseW, h/baseH, 1.2);
    canvas.style.width = `${baseW*scale}px`; canvas.style.height = `${baseH*scale}px`;
  }
  window.addEventListener('resize', fit); fit();

  // Boot
  reset();
  tick();
})();
</script>
</body>
</html>

